#UVA 1388 -- Graveyard

###Introduction:

本题的代码主要依据《算法竞赛入门经典——训练指南》一书，思路也来自这本书，不过在这里补完一些想法与证明。

###Code and Explanation:

```
int main(){
	freopen("1388.in", "r", stdin);
	int n, m; 
	while(cin>>n>>m){
		double ans = 0.0;
		for(int i = 1; i < n; i++){
			double pos = (double)i / n * (n + m);
			ans += abs(pos - floor(pos+0.5)) / (n + m);
		}
		printf("%.4lf\n", ans * 10000);
	}	
	return 0;
}
```

最关键的两行代码的解释：

```
1. double pos = (double)i / n * (n + m)
   // i / n 算得该点在环中本来占的比例，然后这里令(n+m)作为环的总长度的标度
   // 自然可以把当前点在变换后的环中的位置表示出来
   // e.g:
   //    n = 2, m = 1 则对于点 i = 1
   //    原来的环中位置是 1/2, 变换后是 1/2 * 3 = 3/2
2. ans += abs(pos - floor(pos + 0.5)) / (n+m)
   // floor(pos+0.5)是个很巧妙的变换，它将pos四舍五入了
   // 为什么要四舍五入呢？因为变换后该点应该在的位置是整数位置
   // 而四舍五入选择的正好是最近的整数点，至于为什么选最近之后有证明。
   // 拿当前位置减去四舍五入之后的位置再除以(n+m)得到的正好是变换距离的比例
```

###Proof

这一题的证明主要是针对两个关键的假设：

1. 为什么每个点在最优（移动距离最短）的条件下是要移动到距离最近的点？
2. 如果所有点都移动到最近的点，会不会造成有的点没有位置放置？

####proof #1:

这里打算使用交换论证的策略：

* 假如所有点都**可以**移动到距离自己最近的点，那么假设点i目前移动到距离自己最近的点m_i1，它附近还有一个距离次近的点m_i2，这里有两种情况：
    1. m_i2 没有被别的点占据：此时假如i占据m_i2是最优情况，那么令i占据m_i1结果不会更差，因此依然是最优情况。
    2. m_i2 已经被别的点j占据了： 此时如果i要占据m_i2，则要求j另外寻找一个点m_j。易知m_i2是j的最邻近点，那么m_j距离j的距离要比m_i2更远。而且m_j很有可能也被其他的顶点占据，经过层层迭代以后，被影响到的点占据的都不是离自己最近的点。因此如果这种情况是最优解，那么令i占据m_i1会更好。
    
####proof #2:

假如在所有点都移动到最近点的方法上，有的点没有地方放置，假如点i没有地方放置，那么它一定与某个点j的最邻近点有冲突：

如果i与j的最邻近点有冲突，与k没有冲突：那么这里就要求i与j的距离不能超过1/(n+m)，否则他们一定不会共享一个最邻近点。而已知两个点的距离是1/n，所以不成立

证明完毕

###Conclusion

这一题刚拿到的时候一直在尝试各种组合优化策略，实际上每个点之间有很好的相关性，距离相等可以带来许多绝妙的条件。使用贪心法也是理所应当的了。
